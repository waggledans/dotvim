= language =
* pass
* generatore, yield
= scope =
LEGB rule: Local Scope, Enclosing Scope, Global Scope, and Built-in Scope. 
* global var definition:
global name
* global declaration makes function to look for a variabe in enclosing scope
= data types =
boolean True, False
integer, long, float, string, list, tuple, dictionary
object, None, array
= tuples =
# tuples are immutable, ordered.
# len (some_tuple) 
# index (tuple’s element) will return index of the element
# tuples can be indexed from the right some_tuple[-4]  would return the 4th from the right
# some_tuple.count(some_element) will return the number of the elements in the tuple
# search
# in		#’something’ in tuple_name  will return True or False
bool = True
name = "Craig"
age = 26
pi = 3.14159
print(name + ' is ' + str(age) + ' years old.')
#
a = 1
b = 2
def Sum():
   global a, b
   b = a + b
Sum()
print(b)
== named_tuple ==
>>> # Basic example
>>> Point = namedtuple('Point', ['x', 'y'])
>>> p = Point(11, y=22)     # instantiate with positional or keyword arguments
>>> p[0] + p[1]             # indexable like the plain tuple (11, 22)
33
>>> x, y = p                # unpack like a regular tuple
>>> x, y
(11, 22)
>>> p.x + p.y               # fields also accessible by name
33
>>> p                       # readable __repr__ with a name=value style
 =>  Point(x=11, y=22)
= strings = 
* String Slicing
  s = "Go Gators! Come on Gators!"
  x = s[0]  # x = "G" or  x = s[3:9] #x = "Gators" or x = s[:2] #x = "Go" or x = s[19:] #x = "Gators!"
* count substring occurances
  x = s.count("Gator") #x = 2
* endswidth(sub [,start[,end]]): returns true if the string ends with the substr:
  x = s.endswith("Gators") #x = False
int find(sub [,start[,end]]): returns the numeric position of the first occurance of sub in the string. Returns -1 if sub is not found.
  x = s.find("Gator") #x = 3
  x = s.find("gator") #x = -1
* join / split
string join(array): combines elements of the string array into a single string and returns it. 
The separator between elements is the string providing this method.
  a = ['abc','def','ghi']sys.arg
  t = "--"
  x = t.join(a) #x = abc--def--ghi 
  '\n'.join(a)	# 'abc\ndef\nghi\n'
array split([sep [,maxsplit]]): splits a single string into a string array using the separator defined. If no separator is defined, whitespace is used. Consecutive whitespace delimiters are then treated as one delimiter. Optionally you can specify the maximum number of splits so that the max size of the array would be maxsplit+1.
  a = s.split() #a=['Go', 'Gators!', 'Come', 'on', 'Gators!']
* other string functions 
  x = len(s) #x = 26
  print s.lower() #go gators! come on gators!
  print s.upper() #GO GATORS! COME ON GATORS!
string replace(old, new [,count]): returns a copy of the string with all occurances of old replaced by new. If the optional count argument is given, only the first count occurances are replaced.
  x = s.replace("Gators","Tigers",1) #x = Go Tigers! Come on Gators!
int rfind(sub [,start[,end]]): same as find but returns the numeric position of the last occurance of sub in the string.
  x = s.rfind("Gator") #x = 19
boolean startswidth(sub [,start[,end]]): returns true if the string starts with the specified substring and false otherwise:
  x = s.startswith("Go") #x = True
string strip([chars]): returns a copy of the string with leading and trailing characters removed. If chars (a string) is not specified, leading and trailing whitespace is removed.
  line.rstrip()   strips trailing whitespace
* formated strings or print with formated strings
ame = 'marcog'
number = 42
print '%s %d' % (name, number)    # in python2
print("{0} was found {1} times because {0} is there".format(word, count)) # in python3
# first define dictionary
# these strings below expect a dictionary after
# "something %(key_name)s blah-blah" % dictionary
LIGHT_MESSAGES = {
    'English': "There are %(number_of_lights)s lights.",
    'Pirate':  "Arr! Thar be %(number_of_lights)s lights." #this string expects a dictionary
}
def lights_message(language, number_of_lights):
    return LIGHT_MESSAGES[language] % locals()
= regex = 
* re.search
    if re.search('(Len|Neverm)ore', line):
            print(line, end='')   # end is set to nothing cause the line already has newline char
* Group matching
>>> import re
>>> match = re.match('Hello[ \t]*(.*)world', 'Hello Python world') >>> match.group(1)   ==> 'Python '
    if (match): print (match.group())
* replace/sub
    re.sub("(Len|Neverm)ore", "###", line)
    # or
    re.search([[]] line)
    line.replace(match.group(), '###')
* reuse pattern
    pattern = re.compile("(Len|Neverm)ore", re.IGNORECASE)
    re.search(pattern, line)
= HASH DICTIONARY = 
adict = {}
adict["one"] = "uno"
adict = {‘one’:’uno’, ‘two’:’dos’}
print (adict[‘one’])	  # -> uno
* the problem with adict[‘one’] is that it will return error if not defined
* adict.get('one') will return None if not defined
adict.keys()
keys = sorted(adict.keys()) # sorted keys
adict.values()
adict.items()		      # returns tuples (key, value)
if 'key' in adict:     # check that the key is in the hash  
len (adict)	#will return the number of pairs, 2 in this case
adict.pop(‘two’)		#will pop the pair with the key ‘two’
del adict('one')  # deletes key-value pair from the dictionary
* iterating over the dictionary:
for key in adict:
= LIST ARRAY =
* declare
result_list = list()
== shallow copy vs deep copy ==
* shallow copy:
a = [1, 2, 3]
b = a
b[0] = 4  #a[0] also becomes 4
* deep copy:
b = a[:]
== append,count,extend,index,insert,pop,remove,reverse,sort,del,sorted, index ==
["foo", "bar", "baz"].index('bar')      => 1
some_list.remove (element_name)
some_list.insert (2, element_name)		# insert some_element to position indexed 2
some_list.del(2)      # delete element with index 2
some_list.sort ()
sorted(some_list)
sorted(some_list, reverse=True)
sorted(some_list,key=len) # using key function
some_list.reverse ()
list = [2, 4, 7, 9]
list2 = [3, "test", True, 7.4]
a = range(5) #a = [0,1,2,3,4]
a = range(10,0,-2) #a = [10,8,6,4,2]
#An empty list can be init with [] and then the append command can be used to append data :
a=[]
a.append("test")
a.append(5)
print a
-> ['test', 5]
Finally, if you want a list to have a predetermined size- create a list and fill it with None's:
    a=[None]*length
    a[5] = "Fifth"
    a[3] = 6
    print len(a)
    -> 10
    print a
    -> [None, None, None, 6, None, 'Fifth', None, None, None, None]
# Removing from lists: The pop method can be used to remove any item from the list:
a.pop(5)
print a
-> [None, None, None, 6, None, None, None, None, None]
Creating arrays: using one of four procedures: zeros, ones, arange, or array.:
a = zeros(5) #a=[0 0 0 0 0]	# zeros creates an array of a specified size containing all zeros
a = ones(5) #a=[1 1 1 1 1] #ones similarly creates an array of a certain size containing all ones:
arange works exactly the same as range, but produces an array instead of a list:
a = arange(10,0,-2) #a = [10 8 6 4 2] 
array = lists it appears but one can convert list to array using array command
a = [1, 3, 9] #create a list and append it
a.append(3)
a.append(5)
print a
-> [1, 3, 9, 3, 5]
a = array(a)	#converts a list to an array
print a
-> [1 3 9 3 5]
Multi-dimensional lists: Because Python arrays are actually lists, you are allowed to have jagged arrays. Multi-dimensional lists are just lists of lists:
a=[[0,1,2],[3,4,5]]
print a[1]
-> [3, 4, 5]
s = ["Lee", "Walsh", "Roberson"]
s2 = ["Williams", "Redick", "Ewing", "Dockery"]
s3 = [s, s2]
print s3[1][2]
-> Ewing
Multi-dimensional arrays: However, numarray does support true multi-dimensinoal arrays. These can be created through one of five methods: zeros, ones, array, arange, and reshape. zeros and ones work the same way as single dimensions except that they take a tuple of dimensions (a comma separated list enclosed in parentheses) instead of a single argument:
a = zeros((3,5))
a[1,2] = 8
print a
-> [[0 0 0 0 0]
	[0 0 8 0 0]
	[0 0 0 0 0]]
b = ones((2,3,4)) #create a 2x3x4 array containing all ones.
array works the same way as for 1-d arrays: you can create a list and then convert it to an array. Note with multi-dimensional arrays though, trying to use array to convered a jagged list into an array will cause an error. Lists must be rectangular to be able to be converted to arrays.
s = ["Lee", "Walsh", "Roberson", "Brewer"]
s2 = ["Williams", "Redick", "Ewing", "Dockery"]
s3 = [s, s2]
s4 = array(s3)
print s4 + "test"
-> [['Leetest', 'Walshtest', 'Robersontest', 'Brewertest'],
	['Williamstest', 'Redicktest', 'Ewingtest', 'Dockerytest']]
print s4[:,1:3]
-> [['Walsh', 'Roberson'],
	['Redick', 'Ewing']]
arange also works the same as with 1-d arrays except you need to pass the shape parameter:
a = arange(25, shape=(5,5)),br> And finally, reshape can be used to convert a 1-d array into a multi-dimensional array. To create a 5x5 array with the elements numbered from 0 to 24, you could use:
b = arange(25)
b = reshape(b,5,5)
* multidimensional arrays
the format is ([[depth,] height,] width). 
the row is listed first, then the column. 
* array slicing
 - slicing array[i:j], it returns an array containing elements from i to j-1
a=[0 1 2 3 4 5]
 - indices of arrays can be negative, in which case they count from the right instead of the left,
a[-4:-1] = [2 3 4]
 - : can specify the rest of the elements or up to element
print a[:3] #[0 1 2]
print a[4:] #[4 5]
print a[:] #[0 1 2 3 4 5]
print a[[1,3,4]] #[1 3 4]
Note that slicing in python does not create a new array but just a pointer to the original array. b=a[0:10] followed by b[0] = 5 also changes a[0] to 5. To avoid this, use b = copy(a[0:10])
Array Operators:
Concatenation:
Lists: a + b
For Lists, the + operator appends the list on the right (b) to the list on the left.
a = ["Roberson", "Walsh"]
b = ["Lee", "Humphrey"]
-> a+b = ["Roberson", "Walsh", "Lee", "Humphrey"]
Arrays: concatenate((a,b)[,axis])
For arrays, use the numarry function concatenate. It also allows you to specify the axis when concatenating multi-dimensional arrays.
b = arange(5)
print concatenate((b, arange(6)))
-> [0 1 2 3 4 0 1 2 3 4 5]
b=reshape(b,5,1)
print concatenate((b,a),axis=1)
-> [[0 0 0 0]
	[1 0 0 0]
	[2 0 8 0]
	[3 0 0 0]
	[4 0 0 0]]
Equality: a == b and Inequality: a != b
For lists, these work the same as for scalars, meaning they can be used in if statments. For arrays, they return an array containing true or false for each array element.
Array Functions: All functions but len are for arrays only
len: returns the length of a list/array.
   s = ["Lee", "Walsh", "Roberson", "Brewer"]
   print len(s) #4
argmax([axis]): returns the index of the largest element in a 1D array or an array of the largest indices along the specified axis for a multi-dimensional array.
   a = array([[1,6,9], [2,4,0], [7,4,8]])
   print a.argmax(1)
  -> [2 1 2]
argmin([axis]): returns the index of the smallest element in a 1D array or an array of the smallest ndices along the specified axis for a multi-dimensional array.
   b = array([2,4,7,1,3,-1,5])
   print b.argmin()
  -> 5
argsort([axis]): returns an array of indices that allow access to the elements of the array in ascending order.
   print b.argsort()
  -> [5 3 0 4 1 6 2]
   print b[b.argsort()]
  -> [-1 1 2 3 4 5 7]
   print a.argsort(1)
  -> [[0 1 2]
  	[2 0 1]
  	[1 0 2]]
astype(type): returns a copy of the array converted to the specified type.
   a = a.astype('Float64')
   b = b.astype('Int32')
copy(): returns a copy of the array.
   c = a[:,2].copy()
   print c
  -> [9 0 8]
diagonal(): for multi-dimensional arrays, returns the diagonal elements of the array, where the row and column indices are equal.
   print a.diagonal()
  -> [1 4 8]
info(): prints informations about the array which may be useful for debugging.
max(): returns the largest element in the array
   print a.max()
  -> 9
mean(): returns the average of all elements in an array
   print a.mean()
  -> 4.55555555556
min(): returns the smallest element in the array
   print b.min()
  -> -1
nelements(): returns the total number of elements in the array
   print a.nelements()
  -> 9
product(array [,axis]): returns the product of an array or an array of the products along an axis of an array.
   print product(b)
  -> -840
   print product(a,1)
  -> [ 54 0 224]
reshape(array, shape): function that changes the shape of an array. But the new shape must have the same size as the old shape, otherwise an error will occur.
   c = reshape(a, 9)
   a = reshape(c,(3,3))
resize(shape): shrinks/grows the array to a new shape. Can be called as a method (replaces old array) or a function. The new shape does not have to be the same size as the old shape. If it is smaller, values will be cut off, and it if is bigger, values will repeat.
   a.resize(5)
   print a
  -> [1 6 9 2 4]
   a.resize(2,6)
   print a
  -> [[1 6 9 2 4 0]
  	 [7 4 8 1 6 9]]
   c = resize(a,(2,2))
   print c
  -> [[1 6]
  	 [9 2]]
shape(array): returns the dimensions of the array in a tuple
   print shape(a), shape(b), shape(a)[0]*shape(a)[1]
  -> (3,3)    (7,)    9
sort(array [,axis]): returns an array containing a copy of the data in the array and the elements sorted in increasing order. In the case of a multi-dimensional array, the data will be sorted along one axis and not across the whole array.
   print sort(b)
  -> [-1 1 2 3 4 5 7]
   print sort(a)
  -> [[1 6 9]
  	[0 2 4]
  	[4 7 8]]
   print sort(a,0)
  -> [[1 4 0]
  	[2 4 8]
  	[7 6 9]]
stddev(): returns the std deviation of all elements in the array
   print a.stddev()
  -> 3.16666666667
sum(): Can be called as a method or a function. The behavior is identical for 1-d arrays. But for multi-dimensional arrays, calling as a method returns the sum of the entire array, whereas calling it as a function allows you to specify an axis and returns an array with the sums along that axis.
   print a.sum()
  -> 41
   print sum(a)
  -> [10 14 17]
   print sum(a,1)
  -> [16 6 19]
trace(): Returns the sum of the diagonal elements of an array
   print a.trace()
  -> 13
type(): returns a string containing the type of the array.
   print a.type()
  -> Int32
tolist(): returns a list containing the same data as the array.
   c = a.tolist()
transpose(): Can be called as a method (replaces old array) or a function. Returns the transpose of the array.
   a.transpose()
   b = transpose(a)
where(expr, 1, 0): Similar to the IDL where function. Returns an array of the same size and dimensions containing 1 if the condition is true and 0 if the condition is false. Any value may be substituted for 1 and 0, but they are the recommended values (i.e. true, false) so that compress can be used to extract values from the array: compress(mask_array, data_array).
   c = where(b > 2, 1, 0)
   print c
  -> [0 1 1 0 1 0 1]
   print compress(c,b)
  -> [4 7 3 5]
   c = where(a > 2, 1, 0)
   print c
  -> [[0 1 1]
  	[0 1 0]
  	[1 1 1]]
   print compress(c,a)
  -> [6 9 4 7 4 8]
= locals globals =
http://www.diveintopython.net/html_processing/locals_and_globals.html
# locals returns dictionary of name,value of local to function variables
def unknown_starttag(self, tag, attrs):
    strattrs = "".join([' %s="%s"' % (key, value) for key, value in attrs])
    self.pieces.append("<%(tag)s%(strattrs)s>" % locals())
# the function above requires an explanation perhaps, see string formatting above
if __name__ == "__main__":
    for k, v in globals().items():             1
        print k, "=", v
        
= LOOPS =
s = input("Please type some characters and press enter:")
while test < num:
    do_stuff()
else:
    do_other_stuff()
for c in s:
    print(c)
print("Done")
for word in s.split():
    print(word) 
print("Done")

= FUNCTIONS =
def g(x):
    return x**4/4.0 - x**3/3.0 - 3 * x * x
print(g(6))
== keyed functions can passed as an argument ==
def Last(x):
  return x[-1]
sorted(some_list,key=Last)

= EXCEPTIONS =
 * built-in exceptions:
    https://docs.python.org/3/library/exceptions.html
   **   IOError  # when open the file:
        try:
            fh = open("file_name")
        except IOError as e:
            print(e)
   **   ValueError
   **   ZeroDivisionError
        try:
            top = int(input("Please enter the denominator:"))
        except ValueError: # This try-except catches only ValueErrors 
            print ("You didn't enter an integer.")
            exit(0)
        except ZeroDivisionError: # This try-except catches only zero division 
        except:                   # This try-except catches everything
 * custom exceptions       
== measure time with timeit ==
    * from timeit import timeit (first arg is where the module is, the second is name of the method to report cpu time for)
        timeit(setup="from __main__ import resolve", stmt="resolve('python.org')")
= MODULE =
== defining packages ==
 * first create directory and in it create __init__.py
  * install module BeautifulSoup using pip
sudo python -m pip install BeautifulSoup
https://docs.python.org/2/tutorial/modules.html
* good way to import modules:
    try:
        from setuptools import setup
    except ImportError:
        from distutils.core import”

* import module_name # no .py extension
  import reader
  reader.__file__   # will return /full/path/to/file.py
  reader.__name__  # will return string 'reader'
* to import specific function into local namespace do:
  from reader import read_func  
'/Users/dans/Programming/workspace_luna/Python3Training/advanced/reader/reader/reader.py'
* execute module # unlike import that executes module in its namespace, exec overides local vars
exec(open('script1.py').read())
* import sys
  - sys.argv is equivalent to $@ in bash (or @ARGV in perl)
  - argv[0] is a script name
Perl:   ($script, $first, $second, $third) = @ARGV; 
Python: script, first, second, third = argv
* FindBin equivalent
import os
import sys
bindir = os.path.abspath(os.path.dirname(sys.argv[0]))
* from fibo import fib1 ## allows instead of fibo.fib1() run fib1()
= IO operations =
== files ==
 * 
    catfile = open(filename,"r")
    for line in catfile: 
        print(line)
 * using open/readlines
lines = catfile.readlines()	# like perl @lines = <catfile>
line = catfile.read()		# like perl $lines = <catfile>
catfile.close()
outfile = open(filename,"w")
outfile.write("Hello " + yourName + ". How are you?\n") 
outfile.write("Next year you will be "+str(age+1) +" years old\n") 
outfile.close()
== stdin ==
* the simplest way:
age = raw_input("How old are you? ")
age = input("how old are you? ")
*
import fileinput
for line in fileinput.input():
    pass
*
for line in sys.stdin:
    print line
== path manipulations ==
http://docs.python.org/2/library/os.path.html
os.path.expanduser("~dans")     #/home/dans
os.path.split(path)             # splits path to head and tail => (head, tail)
os.path.isfile(path)
os.path.isdir(path)
os.path.islink(path)
os.path.join(path1[, path2[, ...]])
os.path.realpath(path)
os.path.split(os.path.abspath("."))[0]      # the current path "." is expanded to /Users/derek/work, so head is '/Users/derek' and tail is 'work'


=== sys.path adding dirs to the search path ===
 * sys.path[0] is ''   which is equivalent to the current directory
 * Python looks for modules in directories listed in sys.path. Therefore to add a new dir to search path need to: 
import sys
sys.path.append("/home/me/mypy")
 * another way would be by defining PYTHONPATH env variable

== Executing shell commands ==
Execution: os.system('ls -l')
#Requires import os
* execute shell command AND read its output
http://stackoverflow.com/questions/4760215/running-shell-command-from-python-and-capturing-the-output
import subprocess
p = subprocess.Popen(['ls', '-a'], stdout=subprocess.PIPE,  stderr=subprocess.PIPE)
out, err = p.communicate()
print out
def runProcess(exe):    
    p = subprocess.Popen(exe, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    while(True):
      retcode = p.poll() #returns None while subprocess is running
      line = p.stdout.readline()
      yield line
      if(retcode is not None):
        break
= yield =
http://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/
= OOP / object oriented python / class =
== constructors ==
 * "regular"
        def __init__(self, data):
            "Initialize MyData from a sequence"
            self.data = data
 * good practice constructor
        def __init__(self, *args):
            numargs = len(args)
            if numargs < 1: raise TypeError('requires at least one arg')
            elif numargs == 1:
                pass
            elif numargs == 2:
                pass
            else:
                raise TypeError('too many args, received {}'.format(numargs))
                
 * keyword arguments  (dictionaries)
        def __init__(self, **kwargs):
            self.color = kwargs.get('color', 'white') # white is a default value
   donald = Duck(color='blue)         # or donald = Duck()  # white donald
 * combine keyword arguments with list arguments
    def testfunc (this, that, other, *args, **kwargs):      # call it with testfunc(1,2,3,4,4,5,6,5, par1=2, part2=6)
 * getters/setters for ALL members saved in dictionary
        class PolymorphicDuck:
            def __init__(self, **kwargs):
                self.variables = kwargs
            def quack(self):
                print('Quaaack!')
            def set_variable(self, key, value):
                self.variables[key] = value
            def get_variable(self, key):
                return self.variables.get(key, None)
 
== special member methods ==
 * iterator method makes class iterable: __iter__
    def __iter__ (self):     # class can be iterated upon in for koop, as in: for i in some_class(2, 100, 5):
        i = self.lower
        while(i <= self.upper):
            yield i
            i += self.step
 * remember the state between the calls using __call__ function and object __cache__:
    class Resolver:
        def __init__(self):
            self._cache = {}
        def __call__(self, host):
            if host not in self._cache:
                self._cache[host] = socket.gethostbyname(host)
            return self._cache[host]
        def clear(self):
            self._cache.clear()
        def has_host(self, host):
            return host in self._cache
== constructor overloading using factory (@classmethod) ==
>>> class MyData:
...     def __init__(self, data):
...         "Initialize MyData from a sequence"
...         self.data = data
...     @classmethod
...     def fromfilename(cls, filename):
...         "Initialize MyData from a file"
...         data = open(filename).readlines()
...         return cls(data)
...     
...     @classmethod
...     def fromdict(cls, datadict):
...         "Initialize MyData from a dict's items"
...         return cls(datadict.items())
... 
>>> MyData([1, 2, 3]).data
[1, 2, 3]
>>> MyData.fromfilename("/tmp/foobar").data
['foo\n', 'bar\n', 'baz\n']
>>> MyData.fromdict({"spam": "ham"}).data
[('spam', 'ham')]
== Inheritance ==
class Shape:
  def __init__(self):
    self.color = "blue"
class Circle(Shape):  # inherited class
  def __init__(self, r):
    Shape.__init__(self)
    self.radius = r
  def calcDiameter(self):
    return self.radius * 2
== Polymorphism / Overiding ==
  * Python uses "duck" typing ie it quacks like a duck, it is a duck
  * So polymorphism is natural:
== generator ==
http://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/
=== yield ===

    
