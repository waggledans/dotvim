= bash boot source sequence =
/etc/profile
~/.bash_profile
~/.bashrc
~/.bash_login
~/.profile
~/.bash_logout
= switch user =
$ whoami
user1
$ su - user2
Password:
$ whoami
user2
# to switch to root:
$ su -
= general command line commands =
== find ==    
  * combine find with grep:
    find . -name \*.cpp -exec grep -q "debug" '{}' \; -print
  * return file names only
    find . -type f -name "*John*"	
== grep ==    
-l  :only file names are returned
== uniq ==
sort -u -t, -k1,1 file
-u for unique
-t, so comma is the delimiter
-k1,1 for the key field 1
= networking =
curl -i -X POST -H "Content-Type:application/json" -d '{  "firstName" : "Frodo",  "lastName" : "Baggins" }' http://localhost:8080/
* wget
  wget http://ftp.gnu.org/gnu/wget/wget-1.5.3.tar.gz ftp://ftp.gnu.org/gnu/wget/wget-1.10.1.tar.gz.sig
  ** resume download: wget -c 
  ** download in bg: wget -b 
  ** wget --http-user=narad --http-password=password
  ** wget --ftp-user=narad --ftp-password=password 
* scp
scp -i ~/Desktop/amazon.pem ~/Desktop/MS115.fa  ubuntu@ec2-54-166-128-20.compute-1.amazonaws.com:~/data/
* ssh
-L [bind_address:]port:host:hostport
  Specifies that the given port on the local (client) ho
ssh dslov@100.65.0.17 -L 2272:foghorn.systems.wvu.edu:2272 -L 2273:dgtest.systems.wvu.edu:2273 -L 443:dgtest.wvu.edu:443
* netstat
  prints all the ports
= System info =
* lscpu or	      less /proc/cpuinfo
* free <-m|t|g> or    less /proc/meminfo
    ** free -gt, free -mt
* dmidecode --type 17
* lshw -short -C memory
* uname -mrs  : kernel info
* lsb_release -a  : release info (it's not installed everywhere)
* fdisk -l | grep '^Disk /dev/'  : Display installed hard disk and size
ssh -i /Users/dans/ama_test_key.pem ec2-user@52.11.163.16 -v    : AWS ubunthu
ssh -i /Users/dans/ama_test_key.pem ec2-user@52.25.81.84 -v	: amazon_linux
scp  -i ~/ama_test_key.pem ~/Downloads/chef-server.rpm  ec2-user@52.11.163.16:/home/ec2-user/downloads
== Disk administration ==
* check how much space avail in /tmp
df -h /tmp
= user administration =hr-model30-247282
* change user home directory
usermod -m -d /newhome/username username
* add existing user to existing group
  sudo usermod -a -G oinstall dans
grep group-name /etc/group  : check group exists 
* add user/group
groupadd <group-name>	    : create group
useradd -G <group-name> username
* change ownership
id -u			    : user id
id -g           : group id
id -G	    : all user's groups
chown -R `id -u` /data/db	    : change ownership for whatever id-u returns
chgrp -R group_name file/directory_name    : change dir group
= generate key =
== keytool ==
* valid for 3650 days
    keytool -genkey -alias <your alias> -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650
== ssh-keygen ==
* generate public/private key pair. Default is ~/.ssh/id_rsa and ~/.ssh/id_rsa.pub
ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
* Copies the contents of the id_rsa.pub file to your clipboard
    pbcopy < ~/.ssh/id_rsa.pub
* may need to start ssh-agent
    eval "$(ssh-agent -s)"
ssh-add ~/.ssh/id_rsa    
== openssl ==
    * generate private key (using des3 to protect the key by pw)
    openssl genrsa -des3 -out server.key 2048
******  optional sidetrack block to use key to sign **********
    * (optional) see what's inside there
     openssl pkey -in server.key  -text
    * generate public key
     openssl pkey -in server.key -out pub.key -pubout
    echo "sign me message" > messagetosign.txt
    openssl pkeyutl -sign -in messagetosign.txt -inkey server.key -out signature 
    openssl pkeyutl -verify -in messagetosign.txt -sigfile signature -pubin -inkey pub.key
    openssl rsautl -verify  -in signature -pubin -inkey pub.key
    * encrypt the message:
    openssl pkeyutl -encrypt -in plainmessage.txt -pubin -inkey pub.key -out cyphermsg.bin
    * decrypt the message (using private key):
    openssl pkeyutl -decrypt -in cyphermsg.bin -inkey server.key -out  plainmessage.txt

****** end of sidetrack **********
** (optional) to remove passphrase:
    cp server.key server.key.org
    openssl rsa -in server.key.org -out server.key
** generate csr (certificate registration request) 
    openssl req -new -key server.key -out server.csr
** generate self-signed 
    openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
** restart apache and test
    /etc/init.d/httpd stop
    /etc/init.d/httpd start
<<<<<<< HEAD
== crontab ==
EDITOR="gvim" crontab -e
# minute hour day-of-month month day-of-week command
# */20  - here */ means interval ie every 20 min
# Example: run job every 10 min
*/10 * * * * /usr/bin/somedirectory/somecommand
# run job every 10 min as root
*/10 * * * * root /usr/bin/somedirectory/somecommand

== random stuff from old notes ==
get dns server:
nslookup
> server
traceroute
ifconfig -a
flush dns cache:
dscacheutil -flushcache
list dns:
networksetup listallnetworkservices
set default dns server for wifi:
sudo networksetup -setdnsservers Wi-Fi  8.8.8.8
=======

