####################### FORMAT CONVERSION ###############################################

# pilot library should be 
#
# padddr_vsssi
#
cdb2oa -cdslibpath ../cdb/cds.lib.12121 -lib refLib2 -cell cell -view symbol -oalibpath reflibs/refLib2 
oa2cdb -cdslibpath ../cdb/cds.lib.12121 -lib refLib1

;;;;;;;;;;; hsw2skl_mig
;; hsw to skl migration utils: 
/nfs/iil/proj/mpg/procw42/dslov/tools/hsw2skl_mig/bin/skill/replace_templates.il
/nfs/iil/proj/mpg/procw42/dslov/tools/hsw2skl_mig/bin/skill/custom_cells_migration.il
/nfs/iil/proj/mpg/procw42/dslov/tools/hsw2skl_mig/bin/skill/replace_templates.il_yoav
/nfs/iil/proj/mpg/procw42/dslov/tools/hsw2skl_mig/bin/skill/inst_migration.il
;;;;
;;  map file contains the names of the old and the new cell:
a80bgdiode c8xlbgdiodehvm1
;
;;  or with pin mapping:
ah0bfc00nn0a5 cs0gbf00nn0b0 {clk clk} {o clkout} {vcc vcc}
ah0bfc00nn0b0 cs0gbf00nn0b0 {clk clk} {o clkout} {vcc vcc}

cc0blockpremig,cc0gmodaln0d0,testlib,cc0gmodaln0d0,clk,clkin
gives:

tableToList(Pins_Table)
(("testlibcc0gmodaln0d0dcfallencc0blockpremigcc0gmodaln0d0" "dcfallen") 
    ("testlibcc0gmodaln0d0pulsefallenbcc0blockpremigcc0gmodaln0d0" "pulsefallenb") 
    ("testlibcc0gmodaln0d0pulsefallendbcc0blockpremigcc0gmodaln0d0" "pulsefallendb") 
    ("testlibcc0gmodaln0d0flcpordatindcc0blockpremigcc0gmodaln0d0" "flcpordatind") 
    ("testlibcc0gmodaln0d0clkincc0blockpremigcc0gmodaln0d0" "clk") ;; only this one is actually different
    ("testlibcc0gmodaln0d0dcriseenbcc0blockpremigcc0gmodaln0d0" "dcriseenb") 
    ("testlibcc0gmodaln0d0shiftcc0blockpremigcc0gmodaln0d0" "shift") 
    ("testlibcc0gmodaln0d0dcriseencc0blockpremigcc0gmodaln0d0" "dcriseen") 
    ("testlibcc0gmodaln0d0lcppulselcc0blockpremigcc0gmodaln0d0" "lcppulsel") 
    ("testlibcc0gmodaln0d0ckpulse1ncc0blockpremigcc0gmodaln0d0" "ckpulse1n") 
    ("testlibcc0gmodaln0d0dcfallenbcc0blockpremigcc0gmodaln0d0" "dcfallenb")
)

;; snapit gui:
/p/mpg/proc/common2/proj_skill/2.0/schematic/snapit.il

;; fswaid migration gui:
/p/mpg/proc/common2/proj_skill/2.0/fw/LibraryMigration
;; other migration scripts:
/p/mpg/proc/common2/proj_skill/2.0/fw/scaling/migrate1270.pl



;; skl pin masters:
/p/mpg/proc/common2/proj_skill/2.0/schematic/skl/schPinMasters_c9prim.il

;; copy libs (2 examples below):
setenv RUBYLIB $CDSXLATE_ROOT/lib
setenv CDSXLATE_ROOT /nfs/iil/proj/mpg/procw42/dslov/tools/oa_mig/cdsxlate
setenv RUBYLIB $CDSXLATE_ROOT/lib
# Add "mig_" prefix to cell names
copy-libs.rb --cell-rex ^ --cell-rex-subst mig_
# Change "old_" prefix to "new_" prefix in all cells:
$CDSXLATE_ROOT/bin/copy-lib.rb  --cell-rex  ^old_  --cell-rex-subst  new_  <full path to old lib> <full path to new lib
# with blacklist and/or whitelist views:
$CDSXLATE_ROOT/bin/copy-lib.rb  --cell-whitelist-file mycells.txt --view-blacklist 'lnf layout' <full path to old lib> <full path to new lib>

;; dslov: my case was that I wanted to migrate just that part of cc0basic that is used in cc0block
I did the following: a) created csv of cc0block using: "Instance CSV" form
                     b) grepped cc0basic from the csv ie the cells that are used in this library to a file
                     c) copied those cc0basic to another library:
                            $CDSXLATE_ROOT/bin/copy-lib.rb cc0basic cc0basic_mig --cell-whitelist-file cc0basic_cells.txt


;;;;;; one way to generate xlt is:
csv2xlt.rb --csv mymig.csv --xlt mymig.xlt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; XLT syntax
; instance definition
[lib/]cell[/view]  ;; regex can be used [np]4t or process all cells in lib v00basic/.*
[pre-process SKILL code]
[property manipulations]
[post-process SKILL code]
end
;; embeded SKILL code:
<SKILL>
; Load the snapGrid.il module
(load "snapGrid.il")

; Define a function to scale a device width by 0.8 and snap to 0.01 micron grid
(defun scaleDevice (w)
  (CDSXL_snapGrid 0.01 w*0.8))
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; My sample migration file
;; Process instances with cell master name of "nll"
nll
; manipulations go here...
end

;; Process both n and p devices from the primlib library
primlib/^[np]$
; manipulations go here
end

;; Process standard cells
v00basic/.*\
v00clock/.*\
v00sequential/.*
; manipulations go here
end

<SKILL>
;; This code will be executed when CDSxlate is run using this translation
;; file
(printf "Hello world\n")
end
;; end of my sample migration file
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; property manipulations:
; Example of hard-coding size0 instance property
size0 "1.0/0.5"
;Primitive PMOS – scale by 0.8
v9up
size0 propval*0.8
end
;Primitive NMOS – scale by 0.7
v9un
size0 propval*0.7
end
; conditional property change example: Only set area property when the capacitor property is t
un
area if(inst~>capacitor then
        inst~>w * inst~>l
     else
        '__ABORT__
     )
end
;; applying properties to master cells only:
.*
; For all instances, set a cellview property called cellUsed to indicate
; that the master cell was used
(master cellUsed) t
; Similarly, for all cellviews modified by CDSxlate, set a cellview property indicating the cellview was changed
(cellView cellChanged) t
; Cellview and master properties can also be removed
(cellView unusedProp) '__REMOVE__
end
;;; delete a certain cell and prune wires connected to it:
my_device_name
master = 'none
(CDSXL_pruneWiresFromInstPinNames inst t)
end



;;https://intelpedia.intel.com/CDSxlate_%28Dummy_Cells%29
;;; data mining
1. First step is to generate csv with all cells in the library
;; use GUI: cdsxlateForm()  or run:
CDSXL_InstCSVOutdir = "."
(cdsxlate "libname" "cellname" "schematic" (strcat (getShellEnvVar "CDSXLATE_ROOT") "/xlt/instcsv.xlt") 
                    ?interactive t
                    ?recurse t
                    ?all_cells t
                    ?read_only t
                    ?check_save nil)

;; to get:
__TOPCELL__,stdlib,and2,schematic
__CELL__,stdlib,and2,schematic
g1,stdlib,nand2,symbol
g2,stdlib,inv,symbol
__CELL__,stdlib,nand2,schematic
qp0,primlib,p3t,symbol
qp1,primlib,n3t,symbol
;; cell mapping:
egrep -v '^__TOPCELL__|^__CELL__' *.csv | awk -F, '{print $2, $3, $4}' | sed 's/ /,/g' | sort -u

IMPORTANT: Must add the following header to the new file:
old-lib,old-cell,old-view


2. Second step is to generate csv with all cells pin location
(CDSXL_dumpCSVPinLocations inCSVFile outCSVFile)
this step will generate the following file:
group,old-lib,old-cell,old-view,dummy-lib,dummy-cell,dummy-view,inst-lib,inst-cell,inst-view,inst-mag,old-bbox,pin1-net,pin1-shape,pin1-points,pin2-net,pin$
group_1,cc0basic,cc0ann02ln0b0,symbol,dummy_lib,,dummy,,,,1.000000,((0.0 -0.25) (2.05625 0.375)),a,polygon,((0.01875 0.25) (0.00$
group_2,cc0basic,cc0ann02ln0b0,symbolx,dummy_lib,,dummy,,,,1.000000,((0.0 -0.25) (2.06875 0.375)),a,polygon,((0.01875 0.25) (0.00$
group_3,cc0basic,cc0ann92ln0b0,symbol,dummy_lib,,dummy,,,,1.000000,((0.0 -0.25) (2.06875 0.375)),a,polygon,((0.01875 0.25) (0.00$

3. The third step is to update generated outCSVFile with mapping:
group,old-lib,old-cell,old-view,dummy-lib,dummy-cell,dummy-view,inst-lib,inst-cell,inst-view,inst-mag,old-bbox,pin1-net,pin1-shape,pin1-points,pin2-net,pin$
group_1,cc0basic,cc0ann02ln0b0,symbol,dummy_lib,,dummy,ec0,ec0and002al1n02x5,symboli,1.000000,((0.0 -0.25) (2.05625 0.375)),a,polygon,((0.01875 0.25) (0.00$
group_2,cc0basic,cc0ann02ln0b0,symbolx,dummy_lib,,dummy,ec0,ec0and002al1n02x5,symbol,1.000000,((0.0 -0.25) (2.06875 0.375)),a,polygon,((0.01875 0.25) (0.00$
group_3,cc0basic,cc0ann92ln0b0,symbol,dummy_lib,,dummy,ec0,ec0norb02al1n02x5,symboli,1.000000,((0.0 -0.25) (2.06875 0.375)),a,polygon,((0.01875 0.25) (0.00$


4. compare pin location of old cells to new cells:
(CDSXL_compareCSVOldNewPinLocations oldCSVFile newCSVFile)

the output is:
group,old-lib,old-cell,old-view,dummy-lib,dummy-cell,dummy-view,inst-lib,inst-cell,inst-view,inst-mag,old-bbox,pin1-net,pin1-shape,pin1-points,pin2-net,pin2-shape,pin2-points,pin3-net,pin3-shape,pin3-points,pin4-net,pin4-shape,pin4-points,pin5-net,pin5-shape,pin5-points,pin6-net,pin6-shape,pin6-points,pin7-net,pin7-shape,pin7-points,pin8-net,pin8-shape,pin8-points
SAME_PIN_LOCS,cc0basic,cc0ann02ln0b0,symbol,dummy_lib,,dummy,ec0,ec0and002al1n02x5,symboli,1.000000,((0.0 -0.25) (2.05625 0.375)),a,polygon,((0.01875 0.25) (0.00625 0.25625) (0.0 0.25625) (0.0 0.24375) (0.00625 0.24375)),b,polygon,((0.01875 0.0) (0.00625 0.00625) (0.0 0.00625) (0.0 -0.00625) (0.00625 -0.00625)),o,polygon,((1.25 0.125) (1.24375 0.13125) (1.2375 0.13125) (1.2375 0.11875) (1.24375 0.11875))
group_3,cc0basic,cc0ann92ln0b0,symbol,dummy_lib,,dummy,ec0,ec0norb02al1n02x5,symboli,1.000000,((0.0 -0.25) (2.06875 0.375)),a,polygon,((0.01875 0.25) (0.00625 0.25625) (0.0 0.25625) (0.0 0.24375) (0.00625 0.24375)),bb,polygon,((0.01875 0.0) (0.00625 0.00625) (0.0 0.00625) (0.0 -0.00625) (0.00625 -0.00625)),o,polygon,((1.25 0.125) (1.24375 0.13125) (1.2375 0.13125) (1.2375 0.11875) (1.24375 0.11875))

change dummy_lib to some name that bears more info, like to dummy_lib_basic
group,old-lib,old-cell,old-view,dummy-lib,dummy-cell,dummy-view,inst-lib,inst-cell,inst-view,inst-mag,old-bbox,pin1-net,pin1-shape,pin1-points,pin2-net,pin2-shape,pin2-points,pin3-net,pin3-shape,pin3-points,pin4-net,pin4-shape,pin4-points,pin5-net,pin5-shape,pin5-points,pin6-net,pin6-shape,pin6-points,pin7-net,pin7-shape,pin7-points,pin8-net,pin8-shape,pin8-points
SAME_PIN_LOCS,cc0basic,cc0ann02ln0b0,symbol,dummy_lib_basic,,dummy,ec0,ec0and002al1n02x5,symboli,1.000000,((0.0 -0.25) (2.05625 0.375)),a,polygon,((0.01875 0.25) (0.00625 0.25625) (0.0 0.25625) (0.0 0.24375) (0.00625 0.24375)),b,polygon,((0.01875 0.0) (0.00625 0.00625) (0.0 0.00625) (0.0 -0.00625) (0.00625 -0.00625)),o,polygon,((1.25 0.125) (1.24375 0.13125) (1.2375 0.13125) (1.2375 0.11875) (1.24375 0.11875))
SAME_PIN_LOCS,cc0basic,cc0ann02ln0b0,symbolx,dummy_lib_basic,,dummy,ec0,ec0and002al1n02x5,symbol,1.000000,((0.0 -0.25) (2.06875 0.375)),a,polygon,((0.01875 0.25) (0.00625 0.25625) (0.0 0.25625) (0.0 0.24375) (0.00625 0.24375)),b,polygon,((0.01875 0.0) (0.00625 0.00625) (0.0 0.00625) (0.0 -0.00625) (0.00625 -0.00625)),o,polygon,((1.25 0.125) (1.24375 0.13125) (1.2375 0.13125) (1.2375 0.11875) (1.24375 0.11875)),vcc,polygon,((0.875 0.3625) (0.88125 0.36875) (0.88125 0.375) (0.86875 0.375) (0.86875 0.36875))
group_3,cc0basic,cc0ann92ln0b0,symbol,dummy_lib_basic,dummy_gr_3,dummy,ec0,ec0norb02al1n02x5,symboli,1.000000,((0.0 -0.25) (2.06875 0.375)),a,polygon,((0.01875 0.25) (0.00625 0.25625) (0.0 0.25625) (0.0 0.24375) (0.00625 0.24375)),bb,polygon,((0.01875 0.0) (0.00625 0.00625) (0.0 0.00625) (0.0 -0.00625) (0.00625 -0.00625)),o,polygon,((1.25 0.125) (1.24375 0.13125) (1.2375 0.13125) (1.2375 0.11875) (1.24375 0.11875))
group_4,cc0basic,cc0ann92ln0b0,symbolx,dummy_lib_basic,dummy_gr_4,dummy,ec0,ec0norb02al1n02x5,symbol,1.000000,((0.0 -0.25) (2.06875 0.375)),a,polygon,((0.01875 0.25) (0.00625 0.25625) (0.0 0.25625) (0.0 0.24375) (0.00625 0.24375)),bb,polygon,((0.01875 0.0) (0.00625 0.00625) (0.0 0.00625) (0.0 -0.00625) (0.00625 -0.00625)),o,polygon,((1.25 0.125) (1.24375 0.13125) (1.2375 0.13125) (1.2375 0.11875) (1.24375 0.11875)),vcc,polygon,((0.875 0.3625) (0.88125 0.36875) (0.88125 0.375) (0.86875 0.375) (0.86875 0.36875))


5. Need to generate one dummy cell for each group
Make sure that dummy-lib (dummy_lib_basic in our examlple) exists in cds.lib and run:
(CDSXL_createDummyCellsFromCSV "/tmp/tmp/migration/mig/mining/cc0basic_pins_compared.csv"
						?useGroupSeed t
						?mode "w"
						?skipSamePinLocs t
						?skipInstMissing t
						?verbose t)

Or using gui:
CDSXL_dumpCSVPinLocationsFormDisplay()

